# class-jvm

### 类加载过程

```
1）加载：根据查找路径找到相应的class文件，然后导入。类的加载方式分为
隐式加载和显示加载两种。隐式加载指的是程序在使用new关键词创建对象时，会隐式的调用类的加载器把对应的类加载到jvm中。显示加载指的是通过直接调用class.forName（）方法来把所需的类加载到jvm中。
2)  检查：检查夹加载的class文件的正确性。
3)  准备；给类中的静态变量分配内存空间。
4)  解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址。
5)  初始化：对静态变量和静态代码块执行初始化工作。

```

### 主动使用类

```
创建类的实例、
访问某个类或者接口的非final类型的静态变量/对该静态变量赋值
调用类的静态方法
反射
初始化一个类的子类
jvm启动时被标明为启动类的类（如Java Test、main方法所在的类）
jdk1.7开始提供动态语言的支持相关
```

### 接口使用

```
初始化一个类的子类，会先初始化它的父类，但是不一定会初始化它的接口。只有当首次使用该接口的静态变量时，才会初始化
```

### 被动使用类

```
通过子类引用父类的静态字段，为子类的被动使用，不会导致子类初始化
通过数组定义类引用类，为类的被动使用，不会触发此类的初始化
常量在编译阶段会存入调用方法所在的类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化
```



```
Java虚拟机中都由一个类加载器和类本身确定其在虚拟机中的唯一性。当我们比较一个类与另外一个类是否相等的时候，往往是针对同一个类加载器的，如果两个除了类加载器之外其余的信息都是相同的，那么比较这两个类的实例是否是同一个实例返回的也是false的
```

### 创建对象过程

```
Student s = new Student(); 在内存中到底执行了哪些步骤？

1，加载Sutdent.class文件进内存(类加载器)

2，在栈内存为 s 变量申请一个空间

3，在堆内存为Student对象申请空间

4，对类中的成员变量进行默认初始化

5，对类中的成员变量进行显示初始化

6，有构造代码块就先执行构造代码块，如果没有，则省略(此步上文未体现)

7，执行构造方法，通过构造方法对对对象数据进行初始化

8，堆内存中的数据初始化完毕，把内存值复制给 s 变量
```

### jvm物理结构

```
内存 方法区 堆 栈 本地方法栈
垃圾回收器
指令计数器&&寄存器 
执行引擎
本地方法接口
本地方法库
```

#### 方法区

```
永久代 存储已经加载的类信息，常量，静态变量以及方法代码 内存默认为16mb，最大值为64mb
运行时常量池 存储常量和类中符号引用（类名，方法名，字段名），类解析时会将这些符号引用转为直接引用（方法去中内存分配地址）
```

#### 堆区

```
用于存放类的对象实例（new ） jvm启动创建 
大小由参数
-Xms jvm启动申请最小内存 默认为系统物理内存的1/64 不超过1g 
-Xmx jvm可以申请的最大内存 默认为系统物理内存的1/4 不超过1g

按照对象存放的时间不同划分为新生代，老年代，永恒代
新生代(Young)：程序新创建的对象都是从新生代分配内存。可通过-Xmn指定新生代的大小。新生代由Eden和两块相同大小的From，To构成。
老年代(Old)：用于存放经过多次新生代GC仍然存活的对象。新建的对象也可能直接进入老年代，比如大对象(可通过参数指定)和大的数组对象。
永恒代(Perment)：存放类的Meta信息。
```

#### 虚拟机栈

```
一个一个栈帧组成的后进先出的栈式结构，栈帧存放方法运行时的局部变量，方法出口信息
调用一个方法就会在栈中创建一个栈帧存放数据，方法调用结束栈帧消失
```

#### 本地方法栈

```
为Native方法服务
```

#### 程序计数器

```
改变计数器的值来选取下一条需要执行的字节码指令
```

```
堆式程序直接可以使用的内存，其他区域式jvm自己使用的
非堆区内存由参数-XX:PermSize和-XX:MaxPermSize指定。前者指定最小的内存大小，后者指定最大的内存大小。 
程序运行时，JVM会向操作系统申请一块内存，内存的一部分作为堆内存使用，一部分作为非堆内存使用。
```

### 双亲委派

```
用户类加载器->系统类加载器->拓展类加载器->根类加载器
向上委托，向下加载
通过优先级的层次关系避免被重复加载
```

### tomcat加载类

